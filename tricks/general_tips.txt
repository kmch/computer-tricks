Learn a Text Manipulation Language
You spend a large part of each day working with text. Why not have the computer do some of it for you?

Abstractions Live Longer than Details
Invest in the abstraction, not the implementation. Abstractions can survive the barrage of changes from different implementations and new technologies.

Put Abstractions in Code, Details in Metadata
Program for the general case, and put the specifics outside the compiled code base.

Estimate to Avoid Surprises
Estimate before you start. You’ll spot potential problems up front.

Estimate the Order of Your Algorithms
Get a feel for how long things are likely to take before you write code.

Test Your Estimates
Mathematical analysis of algorithms doesn’t tell you everything. Try timing your code in its target environment.

Always Design for Concurrency
Allow for concurrency, and you’ll design cleaner interfaces with fewer assumptions.

Design Using Services
Design in terms of services—independent, concurrent objects behind well-defined, consistent interfaces.





Some Things Are Better Done than Described
Don’t fall into the specification spiral—at some point you need to start coding.

DRY—Don’t Repeat Yourself
Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.

Eliminate Effects Between Unrelated Things
Design components that are self-contained, independent, and have a single, well-defined purpose.

Minimize Coupling Between Modules
Avoid coupling by writing “shy” code and applying the Law of Demeter.

Finish What You Start
Where possible, the routine or object that allocates a resource should be responsible for deallocating it.






Don’t Assume It—Prove It
Prove your assumptions in the actual environment—with real data and boundary conditions.

Test Your Software, or Your Users Will
Test ruthlessly. Don’t make your users find bugs for you.

Crash Early
A dead program normally does a lot less damage than a crippled one.

Don’t Panic When Debugging
Take a deep breath and THINK! about what could be causing the bug.

“select” Isn’t Broken
It is rare to find a bug in the OS or the compiler, or even a third-party product or library. The bug is most likely in the application.

Don’t Think Outside the Box—Find the Box
When faced with an impossible problem, identify the real constraints. Ask yourself: “Does it have to be done this way? Does it have to be done at all?”






Gently Exceed Your Users’ Expectations
Come to understand your users’ expectations, then deliver just that little bit more.

Build Documentation In, Don’t Bolt It On
Documentation created separately from code is less likely to be correct and up to date.

Design with Contracts
Use contracts to document and verify that code does no more and no less than it claims to do.

Use a Project Glossary
Create and maintain a single source of all the specific terms and vocabulary for a project.

Make It Easy to Reuse
If it’s easy to reuse, people will. Create an environment that supports reuse.